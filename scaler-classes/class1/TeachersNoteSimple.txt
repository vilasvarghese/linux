

Agenda: 
	Introduction to Linux (Production & Terminal Focus)
	Machine/Computer?: 
	Hardware Layer: 
	Software Layer: 
	Role of the Operating System: 
	Real-World Example: 
	Introduction to Linux: 
	System Calls for DevOps: 
	GUI vs Shell: 
	Basic commands: 
		File system navigation and management  
			ls 
			cd
			mkdir)
	Shell features 
		(history, aliases, environment variables)


		
			

	Machine 
		Hardware 
		Software
	
	
	Hardware Layer: The Physical World
		CPU (Central processing unit): 
			min. 16 core for production machines 
		RAM (Randomn access memory): 
			Ephemeral
		Storage: 
			Permanent data storage 
				SSDs, 
				HDDs
		Network Interface: 
		Peripherals: 
	Software Layer: 
		Applications: 
		System Software: 
			Programs 
				manage other programs
		Firmware: 
			Low-level code 
				embedded in hardware

	Hardware 
		understands 
			understands specific commands 
		OS helps 
			send specific commands 



			
	applications
		memory
		network
		file storage
		
	compare to hotel concierge if required.
	
		
What the OS Actually Does
--------------------------
OS 
	allocates RAM and tracks usage
	manages disk storage and file organization
	handles network protocols
	creates and manages processes



For Hardware:
	OS Control and manages 
		CPU time 
			between competing applications
		memory allocation and 
			prevents conflicts
		hardware interrupts and 
			device drivers
		system security and stability

Real-World Example: 
	"double-click Chrome, here's what really happens:
	
	1. mouse click (hardware) 
		an interrupt signal
	2. OS detects 
		a. want to run Chrome
			properties in chrome icon 
		b. locates Chrome exe file 
			on your disk
		c. loads Chrome 
			from storage 
				into RAM (memory allocation)
		d. creates a new process 
			unique Process ID for Chrome
		e. allocates CPU time for Chrome to initialize
	Chrome 
		requests network access to 
			load your homepage
	OS 
		manages display 
			show Chraome's window
	Chrome 
		continues making requests 
			(more 
				memory, 
				network calls, 
				file access)
	OS coordinates 
		everything while protecting system security"

-----------------------------------------------------------------------

Why Linux? The Restaurant Chain Analysis
----------------------------------------
Windows Restaurant:
	Costly
	Costly franchise
	closed code 
	user friendly 
Linux Restaurant:
	Free to open anywhere (open source)
	Completely customizable
	community
	Preferred by developers/DevOps
-----------------------------------------------------------------------



	Linux OS Deep Dive: 
		Kernel, 
		User Space and 
		System Calls
	
	
	The Kernel: The Core Manager
	----------------------------
	Kernel Responsibilities:
		Process Management: 
		Memory Management: 
		File System Management: 
		Device Management:
			communicate with h/w through drivers 
		Network Management: 
		Security Management:
			enforce permission and access control 

---------------------------
	Why Kernel is Special:
		Runs in privileged mode 
			(can access hardware directly)
		Always in memory 
			(never gets swapped out)
		complete control 
			over system resources
		Secured - 
			Applications cannot 
			directly access kernel functions

	User Space vs Kernel Space: 
	----------------------------
		The Security Boundary
		User Space (Applications):
			programs etc
		Restricted access - 
			cannot directly control hardware
		If they crash, 
			don't crash the whole system
	Kernel Space (OS Core):
		Device drivers, 
		memory manager, 
		process scheduler
	
	Full hardware access and control
		If 
			kernel crashes, 
				entire system crashes
		Directly manipulates 
			CPU, 
			memory, and 
			devices
		System Calls: 
			The Application-Kernel Interface

	The API Between Worlds
	----------------------
	System calls 
		ordering food at a restaurant. 
	You (application) 
		tells the kernel
	kernel 
		interacts with hardware 
		
	Common System Calls Every DevOps Engineer Should Know:
	-----------------------------------------------------
	api's exposed by kernel 
	File Operations:
		open(): 
			"Give me access to this file"
		read(): 
			"Bring me data from this file"
		write(): 
			"Save this data to the file"
		close(): 
			"I'm done with this file"
	Process Operations:
		fork(): 
			"Create an identical copy of my process"
		exec(): 
			"Replace my process with a different program"
		wait(): 
			"Wait for my child process to complete"
		exit(): 
			"I'm done, clean up my resources"
	Memory Operations:
		mmap(): 
				"Map a file into memory"
		brk(): 
			"Expand my memory space"
	N.B: malloc is exposed by libc and not by kernel 


# Let's see what system calls happen for a simple command

yum install strace in aws 
strace echo "Hello DevOps" 2>&1 | head -20
strace echo "Hello DevOps" 2>&1 | wc -l




	Why This Matters for DevOps
	---------------------------
	Helps in performance debugging:	



GUI vs Shell: The Real Comparison
---------------------------------
	Graphical User Interface (GUI) Strengths:
		Visual and intuitive - 
			Easy to learn
		Discovery-friendly - 
			Can explore 
				by clicking around
		Good for one-off tasks - 
			Opening a file, 
			viewing an image
		Multitasking visual cues - 
			Windows, 
			icons, 
			visual feedback
 

Examples from a typical DevOps Engineer's Day:
---------------------------------------------
Deploy application 
	to 50 servers → 
		Shell: 30 seconds, 
		GUI: 2 hours
Find all log files containing errors → 
	Shell: 5 seconds, 
	GUI: manually impossible
Monitor system resources across cluster → 
	Shell: real-time dashboard, 
	GUI: not scalable
Backup databases with compression → 
	Shell: one command, 
	GUI: multiple steps per database
	
	
	
Free playground for students
	https://webminal.org/register/
	https://linuxzoo.net/ctrl/login.cgi
	what is the recommendation from Scaler 

	
How the Shell Actually Works: Under the Hood
--------------------------------------------
The Shell's Role in the System


The shell sits 
	between 
		you and 
		kernel, 
	like a translator 
	
	
	
				┌─────────────────────────────────────────┐
				│           Your Commands                 │
				│        "ls -la /home"                   │
				└─────────────────┬───────────────────────┘
								  │
				┌─────────────────▼───────────────────────┐
				│              SHELL                      │
				│   • Parses your command                 │
				│   • Finds the program (ls)              │
				│   • Sets up environment                 │
				│   • Handles input/output                │
				└─────────────────┬───────────────────────┘
								  │
				┌─────────────────▼───────────────────────┐
				│           KERNEL                        │
				│   • Executes the program                │
				│   • Manages system resources            │
				│   • Returns results                     │
				└─────────────────┬───────────────────────┘
								  │
				┌─────────────────▼───────────────────────┐
				│           OUTPUT                        │
				│    File listings displayed              │
				└─────────────────────────────────────────┘
				
Shell Processing: 
	Step by Step 
		(We will learn each of below in detailed depth in upcoming classes)


When you type: 
	ls -la /home | grep user | wc -l
		draw this if possible 





Power Feature 1: Command Composition


 
1. ls — List Directory Contents
-------------------------------

	Basic Syntax:
		ls [options] [path]


	Common Usages & Explanations:

	Command	Explanation
	ls			Lists all files and directories in the current directory.
	ls /home	Lists contents of the /home directory.
	ls -l		Long format: shows permissions, owner, group, size, and modification date.
	ls -a		Shows all files, including hidden ones (those starting with .).
	ls -lh		Long format + human-readable sizes (e.g., 2K, 4M, 1G).
	ls -lt		Lists files sorted by modification time (newest first).
	ls -R		Recursively lists contents of all subdirectories.
	ls -lhS 
		-S	Sorts files by size, with the largest first.


	ls -l
	-rw-r--r--  1 user group  5120 Oct  7 10:30 notes.txt
	drwxr-xr-x  2 user user  4096 Oct  7 09:00 Documents

		1 File type & permissions	-rw-r--r--	
		2️ Number of links	
			1	
		3️ Owner name	user	Who owns the file
		4️ Group name	group	Which group owns it
		5️ File size	1234	In bytes
		6️ Last modified date	Oct 8 08:15	When file was last changed
		7️ File name	notes.txt	The name of the file

	-rw-r--r--
		1-	File type (- for file, d for directory, l for symlink)
		2–4	rw-	Owner permissions (user)
		5–7	r--	Group permissions
		8–10	r--	Other users’ permissions



2. cd — Change Directory

	Purpose:
	Used to navigate between directories in the Linux filesystem.

	Basic Syntax:

	cd [directory_path]


	Common Usages & Explanations:

	Command	Explanation
	cd /home	Move into the /home directory.
	cd ./test/test1
	cd ..	Move up one level (to the parent directory).
	cd ../..	Move up two levels.
	cd ~ or cd	Go to the home directory of the current user.
	cd /	Go to the root directory.
	cd -	Switch to the previous directory.
	cd /var/log	Change directory to /var/log.

3. mkdir — Make Directory


	Command	Explanation
	-------------------
	mkdir test	Creates a directory named test in the current location.
	mkdir /tmp/newfolder	Creates a directory at the specified absolute path.
	mkdir -p /home/user/docs/project1	Creates parent directories automatically if they don’t exist.
	mkdir {dir1,dir2,dir3}	Creates multiple directories at once.
	
	
	
Power Feature 2: 
	Command History and Shortcuts



# Navigate command history
	history | tail -10          # See last 10 commands
	!!                          # Repeat last command
	!find              			# Repeat last command starting with 'find'
	!?python?                   # Repeat last command containing 'python'

# Quick navigation
	cd -                        # Go back to previous directory
	Control + R 				# search through the commands executed in the past 


Power Feature 3: Tab Completion Intelligence

# Type and press TAB to see the magic
	cd /ho<TAB>                 # Completes to /home/
	ls -l /etc/pa<TAB>          # Shows all files starting with 'pa'


Power Feature 4: Variables and Environment

bash

# Environment variables - your shell's memory
	echo $HOME                  # Your home directory
	echo $PATH                  # Where shell looks for commands
	echo $USER                  # Your username
	echo $PWD                   # Current directory

# Create your own variables
	export API_KEY="secret123"
	export DATABASE_URL="postgresql://localhost/myapp"
	echo "Connecting to $DATABASE_URL"

# Use in scripts and commands
	cp important.txt $HOME/backups/
	curl https://api.github.com/users/octocat


Shell Customization: Making it Yours
The Power of Aliases

# DevOps-specific aliases
	alias e='export'
	e Hi=Hello
	echo $Hi



Step 1: Understand Your Environment

# Who am I?
whoami
id

# Where am I?
pwd
ls -la

# What kind of system is this?
uname -a
cat /etc/os-release


Step 2: Explore the System Structure

# The root of everything
ls /



# Let's understand what each directory does
echo "This is where programs live:" && ls /bin | head -5
echo "This is where configuration files live:" && ls /etc | head -5
echo "This is where user data lives:" && ls /home

